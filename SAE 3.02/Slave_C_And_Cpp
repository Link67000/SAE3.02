import socket
import threading
import json
import subprocess
import os
import customtkinter

customtkinter.set_appearance_mode("dark")
customtkinter.set_default_color_theme("blue")


class SlaveApp(customtkinter.CTk):
    def __init__(self):
        super().__init__()

        self.client_socket = None
        self.running = False
        self.max_programs = 5  # Par défaut
        self.current_programs = 0
        self.lock = threading.Lock()

        self.title("Slave")
        self.geometry("500x400")

        # Interface utilisateur
        self.master_addr_txt = customtkinter.CTkLabel(self, text="Adresse du Master :")
        self.master_addr_txt.place(x=10, y=10)
        self.master_addr = customtkinter.CTkEntry(self, width=150, justify="center")
        self.master_addr.place(x=180, y=10)
        self.master_addr.insert(0, "192.168.1.80")

        self.master_port_txt = customtkinter.CTkLabel(self, text="Port du Master :")
        self.master_port_txt.place(x=10, y=50)
        self.master_port = customtkinter.CTkEntry(self, width=150, justify="center")
        self.master_port.place(x=180, y=50)
        self.master_port.insert(0, "1111")

        self.start_stop_button = customtkinter.CTkButton(self, text="Démarrer", width=380, height=30, command=self.toggle_connection)
        self.start_stop_button.place(x=10, y=90)

        self.log_box = customtkinter.CTkTextbox(self, width=480, height=200)
        self.log_box.place(x=10, y=130)

        self.protocol("WM_DELETE_WINDOW", self.fermer_proprement)

    def log(self, message):
        self.log_box.insert("1.0", message + "\n")
        print(message)

    def toggle_connection(self):
        if not self.running:
            self.start_client()
            self.start_stop_button.configure(text="Arrêter")
        else:
            self.stop_client()
            self.start_stop_button.configure(text="Démarrer")

    def start_client(self):
        try:
            self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.client_socket.connect((self.master_addr.get(), int(self.master_port.get())))
            self.running = True
            self.log("[*] Connecté au Master.")

            # Envoi du rôle
            role = "C/C++"
            self.client_socket.sendall(role.encode("utf-8"))

            threading.Thread(target=self.listen_to_master, daemon=True).start()
        except Exception as e:
            self.log(f"[!] Erreur : {e}")

    def stop_client(self):
        self.running = False
        if self.client_socket:
            self.client_socket.close()
            self.client_socket = None
        self.log("[*] Déconnecté du Master.")

    def listen_to_master(self):
        while self.running:
            try:
                message = self.client_socket.recv(4096).decode("utf-8")
                if not message:
                    break

                try:
                    data = json.loads(message)
                    file_type = data.get("type_de_fichier", "Inconnu")
                    program_code = data.get("programme", "")
                    load_balancing = data.get("loadB", self.max_programs)
                    self.log(f"[*] Tâche reçue : {file_type}\n[*]Load Balancing : {load_balancing}\n[*] Programme: {program_code}")

                    # Traiter la tâche
                    threading.Thread(target=self.process_task, args=(file_type, program_code, load_balancing)).start()

                except json.JSONDecodeError:
                    self.log("[!] Erreur : données non valides reçues.")
            except Exception as e:
                self.log(f"[!] Erreur de réception : {e}")
                break

    def process_task(self, file_type, program_code, load_balancing):
        try:
            with self.lock:
                if self.current_programs >= load_balancing:
                    self.log("[!] Nombre maximum de programmes atteint.")
                    response = json.dumps({"error": "Nombre maximum de programmes atteint."})
                    self.client_socket.sendall(response.encode("utf-8"))
                    return
                self.current_programs += 1

            # Déterminer le fichier source et le compilateur
            if file_type == "C":
                filename = "temp_program.c"
                compiler = "gcc"
            elif file_type == "C++":
                filename = "temp_program.cpp"
                compiler = "g++"
            else:
                self.log(f"[!] Type de fichier inconnu : {file_type}")
                return

            with open(filename, "w") as f:
                f.write(program_code)

            # Compilation
            compile_command = [compiler, filename, "-o", "temp_program"]
            compile_process = subprocess.run(compile_command, capture_output=True, text=True)

            if compile_process.returncode != 0:
                self.log(f"[!] Erreur de compilation : {compile_process.stderr}")
                response = json.dumps({"error": compile_process.stderr})
                self.client_socket.sendall(response.encode("utf-8"))
                return

            # Exécution
            execute_process = subprocess.run(["./temp_program"], capture_output=True, text=True)

            if execute_process.returncode != 0:
                self.log(f"[!] Erreur d'exécution : {execute_process.stderr}")
                response = json.dumps({"error": execute_process.stderr})
            else:
                self.log(f"[*] Résultat : {execute_process.stdout}")
                response = json.dumps({"resultat": execute_process.stdout})

            self.client_socket.sendall(response.encode("utf-8"))

        except Exception as e:
            self.log(f"[!] Erreur : {e}")
        finally:
            with self.lock:
                self.current_programs -= 1
            # Nettoyage
            os.remove(filename)
            if os.path.exists("temp_program"):
                os.remove("temp_program")

    def fermer_proprement(self):
        self.stop_client()
        self.destroy()


def main():
    app = SlaveApp()
    app.mainloop()


if __name__ == "__main__":
    main()
